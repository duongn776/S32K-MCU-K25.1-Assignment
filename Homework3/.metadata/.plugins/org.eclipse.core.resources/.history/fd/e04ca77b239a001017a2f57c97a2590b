#include "Driver_PORT.h"
#include "Driver_GPIO.h"
#include "core_cm4.h"

#define LED_RED   15   // PD15
#define LED_GREEN 16   // PD16
#define BTN1      12   // PC12
#define BTN2      13   // PC13

extern ARM_DRIVER_GPIO Driver_GPIO0;

/* Callback cho Button - nhận pin number làm parameter */
void Button_Event(ARM_GPIO_Pin_t pin) {
    uint8_t pin_num = GET_PIN(pin);  // Extract pin number từ pin ID

    if (pin_num == BTN1) {
        /* Toggle LED RED */
        uint32_t state = Driver_GPIO0.GetInput(LED_RED);
        Driver_GPIO0.SetOutput(LED_RED, !state);
    }
    else if (pin_num == BTN2) {
        /* Toggle LED GREEN */
        uint32_t state = Driver_GPIO0.GetInput(LED_GREEN);
        Driver_GPIO0.SetOutput(LED_GREEN, !state);
    }
}

int main(void) {

    /* --- Config LED RED (PD15) --- */
    Driver_GPIO0.Setup(LED_RED, NULL);  // LED không cần callback
    Driver_GPIO0.SetDirection(LED_RED, ARM_GPIO_OUTPUT);

    /* --- Config LED GREEN (PD16) --- */
    Driver_GPIO0.Setup(LED_GREEN, NULL);  // LED không cần callback
    Driver_GPIO0.SetDirection(LED_GREEN, ARM_GPIO_OUTPUT);

    /* --- Config Button BTN1 (PC12) với callback --- */
    Driver_GPIO0.Setup(BTN1, Button_Event);  // ✅ Truyền callback function
    Driver_GPIO0.SetDirection(BTN1, ARM_GPIO_INPUT);
    Driver_GPIO0.SetPullResistor(BTN1, ARM_GPIO_PULL_UP);
    Driver_GPIO0.SetEventTrigger(BTN1, ARM_GPIO_TRIGGER_FALLING_EDGE);

    /* --- Config Button BTN2 (PC13) với callback --- */
    Driver_GPIO0.Setup(BTN2, Button_Event);  // ✅ Truyền callback function
    Driver_GPIO0.SetDirection(BTN2, ARM_GPIO_INPUT);
    Driver_GPIO0.SetPullResistor(BTN2, ARM_GPIO_PULL_UP);
    Driver_GPIO0.SetEventTrigger(BTN2, ARM_GPIO_TRIGGER_FALLING_EDGE);

    /* Turn off LED RED and GREEN initially */
    Driver_GPIO0.SetOutput(LED_RED, 1);   // High = OFF (nếu LED active low)
    Driver_GPIO0.SetOutput(LED_GREEN, 1); // High = OFF (nếu LED active low)

    /* Config NVIC for PORTC - driver có thể tự làm, nhưng an toàn thì làm */
    NVIC_ClearPendingIRQ(PORTC_IRQn);
    NVIC_EnableIRQ(PORTC_IRQn);
    NVIC_SetPriority(PORTC_IRQn, 2);

    while (1) {
        __WFI();  // Wait for interrupt
    }
}

/*
 * ISR có thể không cần nữa vì driver tự xử lý và gọi callback
 * Nhưng nếu driver chưa implement thì vẫn giữ:
 */
void PORTC_IRQHandler(void) {
    uint32_t isfr = PORTC->ISFR;

    if (isfr & (1 << BTN1)) {
        Button_Event(MAKE_PIN(IP_PORT_C, BTN1));  // Gọi callback manually
        PORTC->ISFR = (1 << BTN1);
    }
    if (isfr & (1 << BTN2)) {
        Button_Event(MAKE_PIN(IP_PORT_C, BTN2));  // Gọi callback manually
        PORTC->ISFR = (1 << BTN2);
    }
}
